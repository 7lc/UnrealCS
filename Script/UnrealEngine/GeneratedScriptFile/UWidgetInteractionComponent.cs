using System;
namespace UnrealEngine
{
	public partial class UWidgetInteractionComponent:USceneComponent
	{
		/// <summary>Set custom hit result.  This is only taken into account if InteractionSource is set to EWidgetInteractionSource::Custom.</summary>
		public extern void SetCustomHitResult(FHitResult HitResult);
		/// <summary>Gets the last hit location on the widget in 2D, local pixel units of the render target.</summary>
		public extern FVector2D Get2DHitLocation();
		/// <summary>Gets the last hit result generated by the component.  Returns the custom hit result if that was set.</summary>
		public extern FHitResult GetLastHitResult();
		/// <summary>
		/// Returns true if a widget under the hit result is has a visibility that makes it hit test
		/// visible.  e.g. Slate widgets that return true for GetVisibility().IsHitTestVisible().
		/// </summary>
		public extern bool IsOverHitTestVisibleWidget();
		/// <summary>
		/// Returns true if a widget under the hit result is focusable.  e.g. Slate widgets that
		/// return true for SupportsKeyboardFocus().
		/// </summary>
		public extern bool IsOverFocusableWidget();
		/// <summary>
		/// Returns true if a widget under the hit result is interactive.  e.g. Slate widgets
		/// that return true for IsInteractable().
		/// </summary>
		public extern bool IsOverInteractableWidget();
		/// <summary>Get the currently hovered widget component.</summary>
		public extern UWidgetComponent GetHoveredWidgetComponent();
		/// <summary>Sends a scroll wheel event to the widget under the last hit result.</summary>
		public extern virtual void ScrollWheel(float ScrollDelta);
		/// <summary>
		/// Transmits a list of characters to a widget by simulating a OnKeyChar event for each key listed in
		/// the string.
		/// </summary>
		public extern virtual bool SendKeyChar(FString Characters,bool bRepeat=false);
		/// <summary>Does both the press and release of a simulated keyboard key.</summary>
		public extern virtual bool PressAndReleaseKey(FKey Key);
		/// <summary>Releases a key as if it had been released by the keyboard.</summary>
		public extern virtual bool ReleaseKey(FKey Key);
		/// <summary>
		/// Press a key as if it had come from the keyboard.  Avoid using this for 'a-z|A-Z', things like
		/// the Editable Textbox in Slate expect OnKeyChar to be called to signal a specific character being
		/// send to the widget.  So for those cases you should use SendKeyChar.
		/// </summary>
		public extern virtual bool PressKey(FKey Key,bool bRepeat=false);
		/// <summary>
		/// Releases a key as if the mouse/pointer were the source of it.  Normally you would just use
		/// Left/Right mouse button for the Key.  However - advanced uses could also be imagined where you
		/// send other keys to signal widgets to take special actions if they're under the cursor.
		/// </summary>
		public extern virtual void ReleasePointerKey(FKey Key);
		/// <summary>
		/// Presses a key as if the mouse/pointer were the source of it.  Normally you would just use
		/// Left/Right mouse button for the Key.  However - advanced uses could also be imagined where you
		/// send other keys to signal widgets to take special actions if they're under the cursor.
		/// </summary>
		public extern virtual void PressPointerKey(FKey Key);
		/// <summary>
		/// Represents the Virtual User Index.  Each virtual user should be represented by a different
		/// index number, this will maintain separate capture and focus states for them.  Each
		/// controller or finger-tip should get a unique PointerIndex.
		/// </summary>
		public int VirtualUserIndex;
		
		/// <summary>Each user virtual controller or virtual finger tips being simulated should use a different pointer index.</summary>
		public float PointerIndex;
		
		/// <summary>The trace channel to use when tracing for widget components in the world.</summary>
		public ECollisionChannel TraceChannel;
		
		/// <summary>The distance in game units the component should be able to interact with a widget component.</summary>
		public float InteractionDistance;
		
		/// <summary>
		/// Should the interaction component perform hit testing (Automatic or Custom) and attempt to
		/// simulate hover - if you were going to emulate a keyboard you would want to turn this option off
		/// if the virtual keyboard was separate from the virtual pointer device and used a second interaction
		/// component.
		/// </summary>
		public bool bEnableHitTesting;
		
		/// <summary>Shows some debugging lines and a hit sphere to help you debug interactions.</summary>
		public bool bShowDebug;
		
		/// <summary>Determines the color of the debug lines.</summary>
		public FLinearColor DebugColor;
		
		/// <summary>Stores the custom hit result set by the player.</summary>
		public FHitResult CustomHitResult;
		
		/// <summary>The 2D location on the widget component that was hit.</summary>
		public FVector2D LocalHitLocation;
		
		/// <summary>The last 2D location on the widget component that was hit.</summary>
		public FVector2D LastLocalHitLocation;
		
		/// <summary>The widget component we're currently hovering over.</summary>
		public UWidgetComponent HoveredWidgetComponent;
		
		/// <summary>The last hit result we used.</summary>
		public FHitResult LastHitResult;
		
		/// <summary>Are we hovering over any interactive widgets.</summary>
		public bool bIsHoveredWidgetInteractable;
		
		/// <summary>Are we hovering over any focusable widget?</summary>
		public bool bIsHoveredWidgetFocusable;
		
		/// <summary>Are we hovered over a widget that is hit test visible?</summary>
		public bool bIsHoveredWidgetHitTestVisible;
		
		/// <summary>The arrow component we show at editor time.</summary>
		public UArrowComponent ArrowComponent;
		
		
	}
	
}
